<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Picochan: picochan_cu</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Picochan<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Picochan documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__picochan__cu.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">picochan_cu </div></div>
</div><!--header-->
<div class="contents">

<p>Control Unit (CU)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-files" class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:dev_5Fstatus_2Eh" id="r_dev_5Fstatus_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dev__status_8h.html">dev_status.h</a></td></tr>
<tr class="memdesc:dev__status_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device status bit values. <br /></td></tr>
<tr class="memitem:dev_5Fapi_2Eh" id="r_dev_5Fapi_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dev__api_8h.html">dev_api.h</a></td></tr>
<tr class="memdesc:dev__api_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main API for a device on a CU. <br /></td></tr>
<tr class="memitem:devib_2Eh" id="r_devib_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="devib_8h.html">devib.h</a></td></tr>
<tr class="memdesc:devib_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structures and API for a device on a CU. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:pch_5Fcu" id="r_pch_5Fcu"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpch__cu.html">pch_cu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> is a Control Unit (CU)  <a href="structpch__cu.html#details">More...</a><br /></td></tr>
<tr class="memitem:pch_5Fdevib" id="r_pch_5Fdevib"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpch__devib.html">pch_devib</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#gae778375f43278246f52713c263113a2a" title="pch_devib_t represents a device on a CU">pch_devib_t</a> represents a device on a CU  <a href="structpch__devib.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa877558571f3a5b0234cc54dbfd88bdf" id="r_gaa877558571f3a5b0234cc54dbfd88bdf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa877558571f3a5b0234cc54dbfd88bdf">PCH_NUM_CUS</a></td></tr>
<tr class="memdesc:gaa877558571f3a5b0234cc54dbfd88bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of control units.  <br /></td></tr>
<tr class="memitem:ga0efd003a16afa7e31235ae596533c9b0" id="r_ga0efd003a16afa7e31235ae596533c9b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0efd003a16afa7e31235ae596533c9b0">PCH_CU_INIT</a>(num_devices)</td></tr>
<tr class="memdesc:ga0efd003a16afa7e31235ae596533c9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a compile-time initialiser for a <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a>  <br /></td></tr>
<tr class="memitem:ga804c2468b9a775d3f5c26e6375a2279a" id="r_ga804c2468b9a775d3f5c26e6375a2279a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga804c2468b9a775d3f5c26e6375a2279a">MAX_DEVIB_CALLBACKS</a>&#160;&#160;&#160;254</td></tr>
<tr class="memdesc:ga804c2468b9a775d3f5c26e6375a2279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of registered callbacks.  <br /></td></tr>
<tr class="memitem:gac3d768c94fb42cb196655b81f30cf3d4" id="r_gac3d768c94fb42cb196655b81f30cf3d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3d768c94fb42cb196655b81f30cf3d4">NUM_DEVIB_CALLBACKS</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:gac3d768c94fb42cb196655b81f30cf3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the global callbacks array.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad255fd60b677de465d03fa6505775044" id="r_gad255fd60b677de465d03fa6505775044"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpch__cu.html">pch_cu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a></td></tr>
<tr class="memdesc:gad255fd60b677de465d03fa6505775044"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> is a Control Unit (CU)  <br /></td></tr>
<tr class="memitem:ga6924049f57a02761af083fa5498bc092" id="r_ga6924049f57a02761af083fa5498bc092"><td class="memItemLeft" align="right" valign="top"><a id="ga6924049f57a02761af083fa5498bc092" name="ga6924049f57a02761af083fa5498bc092"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>pch_cbindex_t</b></td></tr>
<tr class="memdesc:ga6924049f57a02761af083fa5498bc092"><td class="mdescLeft">&#160;</td><td class="mdescRight">An 8-bit index into an array of callbacks that the CU can make to a device<a class="el" href="#ga6924049f57a02761af083fa5498bc092" title="An 8-bit index into an array of callbacks that the CU can make to a devicepch_cbindex_t is an 8-bit i...">pch_cbindex_t</a> is an 8-bit index into pch_devib_callbacks, an array of up to NUM_DEVIB_CALLBACKS registered callbacks on devibs. <br /></td></tr>
<tr class="memitem:gae778375f43278246f52713c263113a2a" id="r_gae778375f43278246f52713c263113a2a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpch__devib.html">pch_devib</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a></td></tr>
<tr class="memdesc:gae778375f43278246f52713c263113a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#gae778375f43278246f52713c263113a2a" title="pch_devib_t represents a device on a CU">pch_devib_t</a> represents a device on a CU  <br /></td></tr>
<tr class="memitem:ga70efb52d8b560c38dff57960ae653d9b" id="r_ga70efb52d8b560c38dff57960ae653d9b"><td class="memItemLeft" align="right" valign="top"><a id="ga70efb52d8b560c38dff57960ae653d9b" name="ga70efb52d8b560c38dff57960ae653d9b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>pch_devib_callback_t</b>) (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib)</td></tr>
<tr class="memdesc:ga70efb52d8b560c38dff57960ae653d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#ga70efb52d8b560c38dff57960ae653d9b" title="pch_devib_callback_t is a function for the CU to callback a device">pch_devib_callback_t</a> is a function for the CU to callback a device <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5469add7f91acb499ed9d0d1a71d8393" id="r_ga5469add7f91acb499ed9d0d1a71d8393"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5469add7f91acb499ed9d0d1a71d8393">pch_get_devib</a> (<a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a> *cu, <a class="el" href="group__picochan__base.html#gab7ab0df86c352a560a2376290862a2ee">pch_unit_addr_t</a> ua)</td></tr>
<tr class="memdesc:ga5469add7f91acb499ed9d0d1a71d8393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the <a class="el" href="#gae778375f43278246f52713c263113a2a" title="pch_devib_t represents a device on a CU">pch_devib_t</a> of a device from its CU and unit address.  <br /></td></tr>
<tr class="memitem:ga442f8f46a9245648dfaa3e9ed252ab22" id="r_ga442f8f46a9245648dfaa3e9ed252ab22"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga442f8f46a9245648dfaa3e9ed252ab22">pch_get_cu</a> (<a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a> cua)</td></tr>
<tr class="memdesc:ga442f8f46a9245648dfaa3e9ed252ab22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CU for a given control unit address.  <br /></td></tr>
<tr class="memitem:ga176071963f4c0ee29dd30a34a2241edc" id="r_ga176071963f4c0ee29dd30a34a2241edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga176071963f4c0ee29dd30a34a2241edc">pch_cus_init</a> (void)</td></tr>
<tr class="memdesc:ga176071963f4c0ee29dd30a34a2241edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise CU subsystem.  <br /></td></tr>
<tr class="memitem:gaeb9637f1048f58dc46456ed333f08dc2" id="r_gaeb9637f1048f58dc46456ed333f08dc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb9637f1048f58dc46456ed333f08dc2">pch_cus_set_trace</a> (bool trace)</td></tr>
<tr class="memdesc:gaeb9637f1048f58dc46456ed333f08dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether CU subsystem tracing is enabled.  <br /></td></tr>
<tr class="memitem:gad1b76d50296613b3f60ec58c8a17564b" id="r_gad1b76d50296613b3f60ec58c8a17564b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1b76d50296613b3f60ec58c8a17564b">pch_cu_init</a> (<a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a> *cu, uint16_t num_devibs)</td></tr>
<tr class="memdesc:gad1b76d50296613b3f60ec58c8a17564b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a CU with space for num_devibs devices.  <br /></td></tr>
<tr class="memitem:ga06d9bac1fb2e0470773a747f2e21820d" id="r_ga06d9bac1fb2e0470773a747f2e21820d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga06d9bac1fb2e0470773a747f2e21820d">pch_cu_register</a> (<a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a> *cu, <a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a> cua)</td></tr>
<tr class="memdesc:ga06d9bac1fb2e0470773a747f2e21820d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a CU at a control unit address.  <br /></td></tr>
<tr class="memitem:ga464a4dd9ab9789b8e85c67fc288f3777" id="r_ga464a4dd9ab9789b8e85c67fc288f3777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga464a4dd9ab9789b8e85c67fc288f3777">pch_cus_uartcu_configure</a> (<a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a> cua, uart_inst_t *uart, dma_channel_config ctrl)</td></tr>
<tr class="memdesc:ga464a4dd9ab9789b8e85c67fc288f3777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a UART control unit.  <br /></td></tr>
<tr class="memitem:gaca2bd54cbc04af2fac3a3f2114c1f4f5" id="r_gaca2bd54cbc04af2fac3a3f2114c1f4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaca2bd54cbc04af2fac3a3f2114c1f4f5">pch_cus_memcu_configure</a> (<a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a> cua, <a class="el" href="group__picochan__base.html#ga6705e933e26b2eacd30534ef98a638af">pch_dmaid_t</a> txdmaid, <a class="el" href="group__picochan__base.html#ga6705e933e26b2eacd30534ef98a638af">pch_dmaid_t</a> rxdmaid, <a class="el" href="structdmachan__tx__channel.html">dmachan_tx_channel_t</a> *txpeer)</td></tr>
<tr class="memdesc:gaca2bd54cbc04af2fac3a3f2114c1f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a memchan control unit.  <br /></td></tr>
<tr class="memitem:ga74b09005ab0b15100aff9c8ceb943875" id="r_ga74b09005ab0b15100aff9c8ceb943875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga74b09005ab0b15100aff9c8ceb943875">pch_cu_start</a> (<a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a> cua)</td></tr>
<tr class="memdesc:ga74b09005ab0b15100aff9c8ceb943875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the channel from CU cua to the CSS.  <br /></td></tr>
<tr class="memitem:ga79dfde3b47151fb1435d5c052f84888b" id="r_ga79dfde3b47151fb1435d5c052f84888b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga79dfde3b47151fb1435d5c052f84888b">pch_cus_trace_cu</a> (<a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a> cua, bool trace)</td></tr>
<tr class="memdesc:ga79dfde3b47151fb1435d5c052f84888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether tracing is enabled for CU cua.  <br /></td></tr>
<tr class="memitem:gac3b0c2df1a229b612ca6244d265b2358" id="r_gac3b0c2df1a229b612ca6244d265b2358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3b0c2df1a229b612ca6244d265b2358">pch_cus_trace_dev</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, bool trace)</td></tr>
<tr class="memdesc:gac3b0c2df1a229b612ca6244d265b2358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether tracing is enabled for device.  <br /></td></tr>
<tr class="memitem:ga98dd293308d9db0561e6ebdd68edaeef" id="r_ga98dd293308d9db0561e6ebdd68edaeef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdmachan__tx__channel.html">dmachan_tx_channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga98dd293308d9db0561e6ebdd68edaeef">pch_cu_get_tx_channel</a> (<a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a> cua)</td></tr>
<tr class="memdesc:ga98dd293308d9db0561e6ebdd68edaeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the internal tx side of a channel from CU to CSS.  <br /></td></tr>
<tr class="memitem:gac3e9e409735deb678f3aa637929e2308" id="r_gac3e9e409735deb678f3aa637929e2308"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3e9e409735deb678f3aa637929e2308">pch_dev_set_callback</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, int cbindex_opt)</td></tr>
<tr class="memdesc:gac3e9e409735deb678f3aa637929e2308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback for device.  <br /></td></tr>
<tr class="memitem:ga8c56b5359547ca2ab681f3a307f43f5c" id="r_ga8c56b5359547ca2ab681f3a307f43f5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c56b5359547ca2ab681f3a307f43f5c">pch_dev_send_then</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, void *srcaddr, uint16_t n, proto_chop_flags_t flags, int cbindex_opt)</td></tr>
<tr class="memdesc:ga8c56b5359547ca2ab681f3a307f43f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data to the CSS.  <br /></td></tr>
<tr class="memitem:ga9ffb2aff8b77d1fc87336c986de3c1af" id="r_ga9ffb2aff8b77d1fc87336c986de3c1af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9ffb2aff8b77d1fc87336c986de3c1af">pch_dev_send_zeroes_then</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, uint16_t n, proto_chop_flags_t flags, int cbindex_opt)</td></tr>
<tr class="memdesc:ga9ffb2aff8b77d1fc87336c986de3c1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends zeroes to the CSS.  <br /></td></tr>
<tr class="memitem:ga12c045bcf27cf2a4d4331451d9c70af9" id="r_ga12c045bcf27cf2a4d4331451d9c70af9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga12c045bcf27cf2a4d4331451d9c70af9">pch_dev_receive_then</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, void *dstaddr, uint16_t size, int cbindex_opt)</td></tr>
<tr class="memdesc:ga12c045bcf27cf2a4d4331451d9c70af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from the CSS.  <br /></td></tr>
<tr class="memitem:ga3ddc35aaef2f2adea854c65b93a49eb8" id="r_ga3ddc35aaef2f2adea854c65b93a49eb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3ddc35aaef2f2adea854c65b93a49eb8">pch_register_devib_callback</a> (<a class="el" href="#ga6924049f57a02761af083fa5498bc092">pch_cbindex_t</a> n, <a class="el" href="#ga70efb52d8b560c38dff57960ae653d9b">pch_devib_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga3ddc35aaef2f2adea854c65b93a49eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a device callback function at a specific index.  <br /></td></tr>
<tr class="memitem:gade93f39153a74a00a13a0080d994c080" id="r_gade93f39153a74a00a13a0080d994c080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga6924049f57a02761af083fa5498bc092">pch_cbindex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gade93f39153a74a00a13a0080d994c080">pch_register_unused_devib_callback</a> (<a class="el" href="#ga70efb52d8b560c38dff57960ae653d9b">pch_devib_callback_t</a> cb)</td></tr>
<tr class="memdesc:gade93f39153a74a00a13a0080d994c080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a device callback function at an unused index.  <br /></td></tr>
<tr class="memitem:ga659cf5aa8d7ec04d7a6f4dcdda887a35" id="r_ga659cf5aa8d7ec04d7a6f4dcdda887a35"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga659cf5aa8d7ec04d7a6f4dcdda887a35">pch_devib_prepare_callback</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, <a class="el" href="#ga6924049f57a02761af083fa5498bc092">pch_cbindex_t</a> cbindex)</td></tr>
<tr class="memdesc:ga659cf5aa8d7ec04d7a6f4dcdda887a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level API to update devib-&gt;cbindex.  <br /></td></tr>
<tr class="memitem:gac778dd8d87870a413bb9f712784d10b9" id="r_gac778dd8d87870a413bb9f712784d10b9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac778dd8d87870a413bb9f712784d10b9">pch_devib_prepare_count</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, uint16_t count)</td></tr>
<tr class="memdesc:gac778dd8d87870a413bb9f712784d10b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level API to update devib-&gt;payload with a count field.  <br /></td></tr>
<tr class="memitem:ga7f322dd118043b79dcae4dd33dea8a6e" id="r_ga7f322dd118043b79dcae4dd33dea8a6e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f322dd118043b79dcae4dd33dea8a6e">pch_devib_prepare_write_data</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, void *srcaddr, uint16_t n, proto_chop_flags_t flags)</td></tr>
<tr class="memdesc:ga7f322dd118043b79dcae4dd33dea8a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level API to prepare a Data channel operation command for a device.  <br /></td></tr>
<tr class="memitem:ga03805add6a5b0eaef16f9cc7b8669cc6" id="r_ga03805add6a5b0eaef16f9cc7b8669cc6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga03805add6a5b0eaef16f9cc7b8669cc6">pch_devib_prepare_write_zeroes</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, uint16_t n, proto_chop_flags_t flags)</td></tr>
<tr class="memdesc:ga03805add6a5b0eaef16f9cc7b8669cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level API to prepare a Data channel operation command for a device that will implicitly send zeroes.  <br /></td></tr>
<tr class="memitem:ga1b059c3052f1b92e4881178f94b69930" id="r_ga1b059c3052f1b92e4881178f94b69930"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b059c3052f1b92e4881178f94b69930">pch_devib_prepare_read_data</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, void *dstaddr, uint16_t size)</td></tr>
<tr class="memdesc:ga1b059c3052f1b92e4881178f94b69930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level API to prepare a RequestRead channel operation command for a device.  <br /></td></tr>
<tr class="memitem:ga9beeb816e81331c2e0032111670f7348" id="r_ga9beeb816e81331c2e0032111670f7348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9beeb816e81331c2e0032111670f7348">pch_devib_prepare_update_status</a> (<a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *devib, uint8_t devs, void *dstaddr, uint16_t size)</td></tr>
<tr class="memdesc:ga9beeb816e81331c2e0032111670f7348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level API to prepare an UpdateStatus channel operation command for a device.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Control Unit (CU) </p>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ga804c2468b9a775d3f5c26e6375a2279a" name="ga804c2468b9a775d3f5c26e6375a2279a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804c2468b9a775d3f5c26e6375a2279a">&#9670;&#160;</a></span>MAX_DEVIB_CALLBACKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_DEVIB_CALLBACKS&#160;&#160;&#160;254</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of registered callbacks. </p>
<p>A callback index greater than this is handled internally. </p>

</div>
</div>
<a id="gac3d768c94fb42cb196655b81f30cf3d4" name="gac3d768c94fb42cb196655b81f30cf3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3d768c94fb42cb196655b81f30cf3d4">&#9670;&#160;</a></span>NUM_DEVIB_CALLBACKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_DEVIB_CALLBACKS&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the global callbacks array. </p>
<p>Must be a compile-time definition, must not exceed MAX_DEVIB_CALLBACKS (254) and must provide room for any internal specially-defined callbacks. Default 16. </p>

</div>
</div>
<a id="ga0efd003a16afa7e31235ae596533c9b0" name="ga0efd003a16afa7e31235ae596533c9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0efd003a16afa7e31235ae596533c9b0">&#9670;&#160;</a></span>PCH_CU_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCH_CU_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>num_devices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a compile-time initialiser for a <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> </p>
<p>PCH_CU_INIT relies on a non-standard C extension (supported by gcc) to initialise a <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> that includes the space for its devibs array (a Flexible Array Member) at the end of ths struct. The num_devices macro argument is evaluated more than once but since it must be a compile-time constant this should not be a problem. </p>

</div>
</div>
<a id="gaa877558571f3a5b0234cc54dbfd88bdf" name="gaa877558571f3a5b0234cc54dbfd88bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa877558571f3a5b0234cc54dbfd88bdf">&#9670;&#160;</a></span>PCH_NUM_CUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCH_NUM_CUS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of control units. </p>
<p>Must be a compile-time constant between 1 and 256. Default 4. Defines the size of the global array of <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> structures running on this Pico. </p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="gad255fd60b677de465d03fa6505775044" name="gad255fd60b677de465d03fa6505775044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad255fd60b677de465d03fa6505775044">&#9670;&#160;</a></span>pch_cu_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpch__cu.html">pch_cu</a> <a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> is a Control Unit (CU) </p>
<p>The struct starts with a fixed-size metadata section with state and communication information about its devices and channel to the CSS. Immediately following that (ignoring internal padding) is an array of <a class="el" href="#gae778375f43278246f52713c263113a2a" title="pch_devib_t represents a device on a CU">pch_devib_t</a> structures, one for each device on the CU. The size of that array is held in the num_devibs field of the <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> which is set at the time pch_cu_init is called and cannot be changed afterwards. The allocation of memory for a <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a>, whether static or dynamic, is the responsibility of the application before calling pch_cu_init.</p>
<p>The alignment of <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> is enforced to be PCH_CU_ALIGN which is calculated at compile-time as PCH_MAX_DEVIBS_PER_CU multiplied by the smallest power of 2 greater than or equal to sizeof(pch_devib_t). This allows address arithmetic and bit masking to determine the unit address and owning <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> of a devib. PCH_MAX_DEVIBS_PER_CU, a preprocessor symbol, can be defined as any compile-time constant between 1 and 256, defaulting to 32. sizeof(pch_devib_t) is currently 16 so for the default PCH_MAX_DEVIBS_PER_CU, alignof(pch_cu_t) is 512. With the maximum PCH_MAX_DEVIBS_PER_CU of 256, alignof(pch_cu_t) is 4096. Each individual <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> may be allocated at either compile-time or runtime with a smaller numbers of devibs than PCH_MAX_DEVIBS_PER_CU but the alignment as calculated above is still required. </p>

</div>
</div>
<a id="gae778375f43278246f52713c263113a2a" name="gae778375f43278246f52713c263113a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae778375f43278246f52713c263113a2a">&#9670;&#160;</a></span>pch_devib_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpch__devib.html">pch_devib</a> <a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#gae778375f43278246f52713c263113a2a" title="pch_devib_t represents a device on a CU">pch_devib_t</a> represents a device on a CU </p>
<pre class="fragment">DEVIB  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     next      |    cbindex    |          size                 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |       op      |     flags     |         payload               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          bufaddr                              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                            sense                              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre> 
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga98dd293308d9db0561e6ebdd68edaeef" name="ga98dd293308d9db0561e6ebdd68edaeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98dd293308d9db0561e6ebdd68edaeef">&#9670;&#160;</a></span>pch_cu_get_tx_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmachan__tx__channel.html">dmachan_tx_channel_t</a> * pch_cu_get_tx_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a></td>          <td class="paramname"><span class="paramname"><em>cua</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the internal tx side of a channel from CU to CSS. </p>
<p>This function is only needed when configuring a memchan between a CU and the CSS on different cores of a single Pico. The CSS initialisation procedure uses this function to find its peer CU structure in order to cross-connect the channels. </p>

</div>
</div>
<a id="gad1b76d50296613b3f60ec58c8a17564b" name="gad1b76d50296613b3f60ec58c8a17564b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1b76d50296613b3f60ec58c8a17564b">&#9670;&#160;</a></span>pch_cu_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pch_cu_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>cu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_devibs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a CU with space for num_devibs devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cu</td><td>Must be a pointer to enough space to hold the <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a> structure including its flexible array that must itself have room for num_devibs <a class="el" href="#gae778375f43278246f52713c263113a2a" title="pch_devib_t represents a device on a CU">pch_devib_t</a> structures. </td></tr>
    <tr><td class="paramname">num_devibs</td><td>The number of devices to initialise</td></tr>
  </table>
  </dd>
</dl>
<p>Typically, the PCH_CU_INIT macro is used as a static initialiser instead of needing to call this function on an uninitialised <a class="el" href="#gad255fd60b677de465d03fa6505775044" title="pch_cu_t is a Control Unit (CU)">pch_cu_t</a>. </p>

</div>
</div>
<a id="ga06d9bac1fb2e0470773a747f2e21820d" name="ga06d9bac1fb2e0470773a747f2e21820d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06d9bac1fb2e0470773a747f2e21820d">&#9670;&#160;</a></span>pch_cu_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pch_cu_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>cu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a></td>          <td class="paramname"><span class="paramname"><em>cua</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a CU at a control unit address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cu</td><td>the CU to register </td></tr>
    <tr><td class="paramname">cua</td><td>control unit address to register as</td></tr>
  </table>
  </dd>
</dl>
<p>No CU must yet have been registered as control unit address cua. cu must already have been initialised either with static initialiser <a class="el" href="#ga0efd003a16afa7e31235ae596533c9b0" title="a compile-time initialiser for a pch_cu_t">PCH_CU_INIT()</a> or by calling <a class="el" href="#gad1b76d50296613b3f60ec58c8a17564b" title="Initialises a CU with space for num_devibs devices.">pch_cu_init()</a>. </p>

</div>
</div>
<a id="ga74b09005ab0b15100aff9c8ceb943875" name="ga74b09005ab0b15100aff9c8ceb943875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74b09005ab0b15100aff9c8ceb943875">&#9670;&#160;</a></span>pch_cu_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pch_cu_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a></td>          <td class="paramname"><span class="paramname"><em>cua</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the channel from CU cua to the CSS. </p>
<p>The CU must already have been registered by calling <a class="el" href="#ga06d9bac1fb2e0470773a747f2e21820d" title="Registers a CU at a control unit address.">pch_cu_register()</a>. If the CU has already been started, this function returns without doing anything. If no DMA IRQ index has yet been explicitly configured for this CU then pch_cus_auto_configure_dma_irq_index(true) is called and pch_cu_set_dma_irq_index() is called to set the CU to use the returned index. Then it marks the CU as started and starts the channel to the CSS, allowing it to receive commands from the CSS. </p>

</div>
</div>
<a id="ga176071963f4c0ee29dd30a34a2241edc" name="ga176071963f4c0ee29dd30a34a2241edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga176071963f4c0ee29dd30a34a2241edc">&#9670;&#160;</a></span>pch_cus_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pch_cus_init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise CU subsystem. </p>
<p>Must be called before any other CU function. </p>

</div>
</div>
<a id="gaca2bd54cbc04af2fac3a3f2114c1f4f5" name="gaca2bd54cbc04af2fac3a3f2114c1f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca2bd54cbc04af2fac3a3f2114c1f4f5">&#9670;&#160;</a></span>pch_cus_memcu_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pch_cus_memcu_configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a></td>          <td class="paramname"><span class="paramname"><em>cua</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga6705e933e26b2eacd30534ef98a638af">pch_dmaid_t</a></td>          <td class="paramname"><span class="paramname"><em>txdmaid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga6705e933e26b2eacd30534ef98a638af">pch_dmaid_t</a></td>          <td class="paramname"><span class="paramname"><em>rxdmaid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmachan__tx__channel.html">dmachan_tx_channel_t</a> *</td>          <td class="paramname"><span class="paramname"><em>txpeer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a memchan control unit. </p>
<p>A memchan control unit allows the CU to run on one core of a Pico while the CSS runs on the other core. Instead of using physical pins or connections between CU and CSS, picochan uses the DMA channels to copy memory-to-memory between CU and CSS and an internal state machine and cross-core synchronisation to mediate CU to CSS communications. txdmaid and rxdmaid must be two unused DMA ids, typically allocated using dma_claim_unused_channel(). In order for the CU to find the CSS-side information to cross-connect the sides in memory, the CSS API function <a class="el" href="group__picochan__css.html#ga1ff6be2ad0654c29681d3d0332e57c89" title="Fetch the internal tx side of a channel from CSS to CU.">pch_chp_get_tx_channel()</a> must be used to fetch the internal dmachan_tx_channel_t of the peer CSS channel for passing to pch_cus_memcu_configure. </p>

</div>
</div>
<a id="gaeb9637f1048f58dc46456ed333f08dc2" name="gaeb9637f1048f58dc46456ed333f08dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb9637f1048f58dc46456ed333f08dc2">&#9670;&#160;</a></span>pch_cus_set_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pch_cus_set_trace </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trace</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether CU subsystem tracing is enabled. </p>
<p>If this flag is not set to be true then no CU trace records are written, regardless of any per-CU or per-device trace flags. </p>

</div>
</div>
<a id="ga79dfde3b47151fb1435d5c052f84888b" name="ga79dfde3b47151fb1435d5c052f84888b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79dfde3b47151fb1435d5c052f84888b">&#9670;&#160;</a></span>pch_cus_trace_cu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pch_cus_trace_cu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a></td>          <td class="paramname"><span class="paramname"><em>cua</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trace</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether tracing is enabled for CU cua. </p>
<p>If this flag is not set to be true then no CU trace records are written for this CU and no device trace records, regardless of any per-device trace flags. </p>

</div>
</div>
<a id="gac3b0c2df1a229b612ca6244d265b2358" name="gac3b0c2df1a229b612ca6244d265b2358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3b0c2df1a229b612ca6244d265b2358">&#9670;&#160;</a></span>pch_cus_trace_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pch_cus_trace_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trace</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether tracing is enabled for device. </p>
<p>If this flag is set to true and the trace flag is set for the CU subsystem as a whole (with pch_cus_set_trace) and the trace flag is set for the device's CU (with pch_cus_trace_cu) then device trace records are written for this device. If this function changes the setting of the device's trace flag then a trace record is written to indicate this (unlike using the low-level pch_devib_set_traced() function). </p>

</div>
</div>
<a id="ga464a4dd9ab9789b8e85c67fc288f3777" name="ga464a4dd9ab9789b8e85c67fc288f3777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464a4dd9ab9789b8e85c67fc288f3777">&#9670;&#160;</a></span>pch_cus_uartcu_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pch_cus_uartcu_configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a></td>          <td class="paramname"><span class="paramname"><em>cua</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_inst_t *</td>          <td class="paramname"><span class="paramname"><em>uart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dma_channel_config</td>          <td class="paramname"><span class="paramname"><em>ctrl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a UART control unit. </p>
<p>Configure the hardware UART instance uart as a channel from CU cua to the CSS. The UART must have been initialised already, be connected to the CSS using the same baud rate as the CSS has configured and the hardware flow control pins, CTS and RTS MUST be enabled and connected between CU and CSS. ctrl should typically be a default dma_channel_config as returned from dma_channel_get_default_config(dmaid) invoked on any DMA id. Most bits in that dma_channel_config are overridden by the CU (including the CHAIN_TO which is why the dmaid above does not matter) but some applications may wish to set bits SNIFF_EN and HIGH_PRIORITY for their own purposes.</p>
<p>If you want to initialise and configure the UART channel using a given baud rate, suggested UART settings (8E1) and default DMA control register settings (no SNIFF_EN and no HIGH_PRIORITY), you can use <a class="el" href="group__picochan__css.html#gae8d99610900108b3b9ea3cc460784b5c" title="Initialise and configure a UART control unit with default dma_channel_config control register.">pch_cus_auto_configure_uartcu()</a> instead. </p>

</div>
</div>
<a id="ga12c045bcf27cf2a4d4331451d9c70af9" name="ga12c045bcf27cf2a4d4331451d9c70af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c045bcf27cf2a4d4331451d9c70af9">&#9670;&#160;</a></span>pch_dev_receive_then()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pch_dev_receive_then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dstaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cbindex_opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data from the CSS. </p>
<p>This, and related variants, is the primary function used to receive data from the CSS from the source address and count specified in a CCW segment with a Write-type command. Before calling this function, the device must have verified that the CSS is expecting to send data, i.e.</p><ul>
<li>the Start callback must have been called for the device and the device has not since sent an UpdateStatus including ChannelEnd</li>
<li>and the CCW command must have been Write-Type (the devib-&gt;flags field must have the PCH_DEVIB_FLAG_CMD_WRITE bit set).</li>
</ul>
<p>If the device requests more data than the CCW segment contains then the amount of data sent to the device will be safely capped at the available amount but additional effects depend on flags set in the CCW and, possibly, the subchannel. A request by the device for more data than is available is an "Incorrect Length Condition" and, unless the channel program has included the PCH_CCW_FLAG_SLI ("Suppress Length Indication") flag in the CCW, will cause the channel program to stop any data chaining or command chaining and end (eventually) with a subchannel status field including the PCH_SCHS_INCORRECT_LENGTH flag. It is up to the device driver author to be aware of the effects the request counts may have on the channel program and, ideally, use them and document them in a way that allows the channel program author to construct channel programs that can make good use of the additional length checks or have them ignored where appropriate.</p>
<p>The <span class="tt">devib-&gt;size</span> field will have been filled in at Start time with a size that is no more than (and will typically be very close to) the size specified by the CCW segment itself. Following a call to <span class="tt"><a class="el" href="#ga12c045bcf27cf2a4d4331451d9c70af9" title="Receive data from the CSS.">pch_dev_receive_then()</a></span> or its variants, the response from the CSS includes an exact up-to-date count of the remaining available room in the CCW segment and the CU updates the <span class="tt">devib-&gt;size</span> field with this value before invoking the next callback on the device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cu</td><td>- the control unit </td></tr>
    <tr><td class="paramname">ua</td><td>- the unit address of the device in control unit <span class="tt">cu</span> </td></tr>
    <tr><td class="paramname">dstaddr</td><td>- the address to receive the data sent by the CSS </td></tr>
    <tr><td class="paramname">size</td><td>- the number of data bytes requested - the number of bytes actually received will be at most <span class="tt">n</span> but may be strictly less. </td></tr>
    <tr><td class="paramname">cbindex_opt</td><td>- before sending, update the callback index in the devib (unless -1 is passed) ready for the next callback to the device, which will happen after the data has been received and the CU has updated the <span class="tt">devib-&gt;size</span> field with the remaining count of available data bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c56b5359547ca2ab681f3a307f43f5c" name="ga8c56b5359547ca2ab681f3a307f43f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c56b5359547ca2ab681f3a307f43f5c">&#9670;&#160;</a></span>pch_dev_send_then()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pch_dev_send_then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>srcaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proto_chop_flags_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cbindex_opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data to the CSS. </p>
<p>This, and related variants, is the primary function used to send data to the CSS satisfying some or all of a CCW segment with a Read-type command. Before calling this function, the device must have verified that (1) the CSS is expecting data to be sent and (2) the amount of data it sends is no more than the maximum space advertised by the CSS. For (1),</p><ul>
<li>the Start callback must have been called for the device and the device has not since sent an UpdateStatus including ChannelEnd</li>
<li>and the CCW command must have been Read-Type (the devib-&gt;flags field must have the PCH_DEVIB_FLAG_CMD_WRITE bit as zero).</li>
</ul>
<p>For (2), provided (1) holds, the devib-&gt;size field will have been filled in at Start time with a size that is no more than (and will typically be very close to) the size specified by the CCW segment itself. However, the size field is not affected by using this or related functions to send data to the CSS (and the field should not be updated in such a way by the device). Use the PROTO_CHOP_FLAG_RESPONSE_REQUIRED flag (see below) if up-to-date and/or exact size information is needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cu</td><td>- the control unit </td></tr>
    <tr><td class="paramname">ua</td><td>- the unit address of the device in control unit <span class="tt">cu</span> </td></tr>
    <tr><td class="paramname">flags</td><td>- may contain the following flags:<ul>
<li>PROTO_CHOP_FLAG_RESPONSE_REQUIRED -request that the CSS send an update (a Room operation) that causes the CU to update the <span class="tt">devib-&gt;size</span> field with up-to-date and exact information.</li>
<li>PROTO_CHOP_FLAG_END - after sending the data, the CSS will behave as though the device has sent a final device status with no unusual conditions (DeviceEnd|ChannelEnd and no other bits set).</li>
<li>PROTO_CHOP_FLAG_SKIP - instead of sending n data bytes down the channel, the CSS will behave as though n bytes of zeroes were sent. If this flag is set, srcaddr is ignored.</li>
</ul>
</td></tr>
    <tr><td class="paramname">srcaddr</td><td>- the address of the data to be sent (ignored if flags contains PROTO_CHOP_FLAG_SKIP) </td></tr>
    <tr><td class="paramname">n</td><td>- the number of data bytes to send </td></tr>
    <tr><td class="paramname">cbindex_opt</td><td>- before sending, update the callback index in the devib (unless -1 is passed) ready for the next callback to the device. The event that will cause the next callback depends on the flags:<ul>
<li>PROTO_CHOP_FLAG_RESPONSE_REQUIRED - the callback will happen after the CSS has replied with its Room operation and the CU has updated the <span class="tt">devib-&gt;size</span> field with an up-to-date and exact size.</li>
<li>PROTO_CHOP_FLAG_END - the next callback will be when the next CCW is processed causing a Start to the device (whether a CCW command-chained from the previous channel program or a new channel program - the difference is not visible to the device).</li>
<li>any other combination - the callback will happen as soon as the CU has completed sending the command+data to the CSS meaning that the device can invoke further API calls if it wishes. Whether any new API calls will cause commands to be sent to the CSS immediately depends on whether any other devices have commands that are being sent or are pending ahead of new requests from this device. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ffb2aff8b77d1fc87336c986de3c1af" name="ga9ffb2aff8b77d1fc87336c986de3c1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ffb2aff8b77d1fc87336c986de3c1af">&#9670;&#160;</a></span>pch_dev_send_zeroes_then()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pch_dev_send_zeroes_then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proto_chop_flags_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cbindex_opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends zeroes to the CSS. </p>
<p>Convenience function that calls pch_dev_send_then with a flags field that ORs in PROTO_CHOP_FLAG_SKIP and an (ignored) srcaddr of 0. </p>

</div>
</div>
<a id="gac3e9e409735deb678f3aa637929e2308" name="gac3e9e409735deb678f3aa637929e2308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3e9e409735deb678f3aa637929e2308">&#9670;&#160;</a></span>pch_dev_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pch_dev_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cbindex_opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set callback for device. </p>
<p>Sets, changes or unsets the callback function that the CU invokes when action is needed from the device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cu</td><td>the CU to which the device belongs </td></tr>
    <tr><td class="paramname">ua</td><td>the unit address of the device within its CU </td></tr>
    <tr><td class="paramname">cbindex_opt</td><td>either a callback index (<a class="el" href="#ga70efb52d8b560c38dff57960ae653d9b" title="pch_devib_callback_t is a function for the CU to callback a device">pch_devib_callback_t</a>) of a callback function registered with pch_register_devib_callback or one of the following special values:<ul>
<li>PCH_DEVIB_CALLBACK_DEFAULT - any attempt by the CSS to start a channel program for this device will result in the CU responding on its behalf with a final device status (ChannelEnd|DeviceEnd) with UnitCheck set and a sense code set with CommandReject with additional code EINVALIDDEV. Any attempt to callback the device at any other point in its lifecycle will result in the CU responding on its behalf with a final device status (ChannelEnd|DeviceEnd) with UnitCheck set and a sense code set with ProtoError, an additional code of the requested operation and ASC and ASCQ containing the bytes p0 and p1, respectively, of the operation packet payload.</li>
<li>PCH_DEVIB_CALLBACK_NOOP - any attempt to callback this device will be silently ignored. For this to be at all useful, the device must be specially written to determine any actions needed of it independently of the usual CU-to-device communication mechanisms.</li>
<li>-1 - the device callback is not changed </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga659cf5aa8d7ec04d7a6f4dcdda887a35" name="ga659cf5aa8d7ec04d7a6f4dcdda887a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga659cf5aa8d7ec04d7a6f4dcdda887a35">&#9670;&#160;</a></span>pch_devib_prepare_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pch_devib_prepare_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6924049f57a02761af083fa5498bc092">pch_cbindex_t</a></td>          <td class="paramname"><span class="paramname"><em>cbindex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level API to update devib-&gt;cbindex. </p>
<p>The cbindex field determines the callback that the CU will invoke the next time an event happens that needs handling by the device. For a Debug build, asserts if cbindex is invalid (out of range or unregistered).</p>
<p>Typically, device driver authors should use the higher-level pch_dev_ API rather than this low-level API. </p>

</div>
</div>
<a id="gac778dd8d87870a413bb9f712784d10b9" name="gac778dd8d87870a413bb9f712784d10b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac778dd8d87870a413bb9f712784d10b9">&#9670;&#160;</a></span>pch_devib_prepare_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pch_devib_prepare_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level API to update devib-&gt;payload with a count field. </p>
<p>The payload of a RequestRead or Data channel operation command provides the count of data bytes that are requested from the channel or are to be sent to the channel.</p>
<p>Typically, device driver authors should use the higher-level pch_dev_ API rather than this low-level API. </p>

</div>
</div>
<a id="ga1b059c3052f1b92e4881178f94b69930" name="ga1b059c3052f1b92e4881178f94b69930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b059c3052f1b92e4881178f94b69930">&#9670;&#160;</a></span>pch_devib_prepare_read_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pch_devib_prepare_read_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dstaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level API to prepare a RequestRead channel operation command for a device. </p>
<p>Uses pch_devib_prepare_count to set the count of bytes that are to be requested, sets the destination address for the bytes and sets the channel operation command to be PROTO_CHOP_REQUEST_READ.</p>
<p>For a Debug build, asserts if the device has not received a Start operation.</p>
<p>Typically, device driver authors should use the higher-level pch_dev_ API rather than this low-level API. </p>

</div>
</div>
<a id="ga9beeb816e81331c2e0032111670f7348" name="ga9beeb816e81331c2e0032111670f7348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9beeb816e81331c2e0032111670f7348">&#9670;&#160;</a></span>pch_devib_prepare_update_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pch_devib_prepare_update_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>devs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dstaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level API to prepare an UpdateStatus channel operation command for a device. </p>
<p>Sets the channel operation command to be PROTO_CHOP_UDPATE_STATUS. Sets the device status (devs) in the payload. If it's either an unsolicited status (neither ChannelEnd nor DeviceEnd set) or it's end-of-channel-program (both ChannelEnd and DeviceEnd set) then it also sets the devib addr field to dstaddr, the size field to field and encodes the (16-bit) size as an 8-bit "bsize" value within the payload. A non-zero value of the size advertises to the CSS the buffer and length to which the next CCW Write-type command can immediately send data during Start.</p>
<p>For a Debug build, asserts if the device has not received a Start operation.</p>
<p>Typically, device driver authors should use the higher-level pch_dev_ API rather than this low-level API. </p>

</div>
</div>
<a id="ga7f322dd118043b79dcae4dd33dea8a6e" name="ga7f322dd118043b79dcae4dd33dea8a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f322dd118043b79dcae4dd33dea8a6e">&#9670;&#160;</a></span>pch_devib_prepare_write_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pch_devib_prepare_write_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>srcaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proto_chop_flags_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level API to prepare a Data channel operation command for a device. </p>
<p>Uses pch_devib_prepare_count to set the count of bytes to be written, sets the source address for the bytes and sets the channel operation command to be PROTO_CHOP_DATA along with any provided flags.</p>
<p>For a Debug build, asserts if the device has not received a Start operation.</p>
<p>Typically, device driver authors should use the higher-level pch_dev_ API rather than this low-level API. </p>

</div>
</div>
<a id="ga03805add6a5b0eaef16f9cc7b8669cc6" name="ga03805add6a5b0eaef16f9cc7b8669cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03805add6a5b0eaef16f9cc7b8669cc6">&#9670;&#160;</a></span>pch_devib_prepare_write_zeroes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pch_devib_prepare_write_zeroes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> *</td>          <td class="paramname"><span class="paramname"><em>devib</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">proto_chop_flags_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level API to prepare a Data channel operation command for a device that will implicitly send zeroes. </p>
<p>Uses pch_devib_prepare_count to set the count of zero bytes to be written and sets the channel operation command to be PROTO_CHOP_DATA together with the PROTO_CHOP_FLAG_SKIP flag that means that the CU does not have to send any actual data bytes down the channel and causes the CSS to write zero bytes itself directly to the CCW's destination address.</p>
<p>For a Debug build, asserts if the device has not received a Start operation.</p>
<p>Typically, device driver authors should use the higher-level pch_dev_ API rather than this low-level API. </p>

</div>
</div>
<a id="ga442f8f46a9245648dfaa3e9ed252ab22" name="ga442f8f46a9245648dfaa3e9ed252ab22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga442f8f46a9245648dfaa3e9ed252ab22">&#9670;&#160;</a></span>pch_get_cu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a> * pch_get_cu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#ga0cf813e237e3a90e67a308ee9865a011">pch_cuaddr_t</a></td>          <td class="paramname"><span class="paramname"><em>cua</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the CU for a given control unit address. </p>
<p>For a Debug build, asserts when cua exceeds the (compile-time defined) number of CUs, PCH_NUM_CUS, or if the CU has not been initialised with pch_cu_init. </p>

</div>
</div>
<a id="ga5469add7f91acb499ed9d0d1a71d8393" name="ga5469add7f91acb499ed9d0d1a71d8393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5469add7f91acb499ed9d0d1a71d8393">&#9670;&#160;</a></span>pch_get_devib()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gae778375f43278246f52713c263113a2a">pch_devib_t</a> * pch_get_devib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gad255fd60b677de465d03fa6505775044">pch_cu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>cu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__picochan__base.html#gab7ab0df86c352a560a2376290862a2ee">pch_unit_addr_t</a></td>          <td class="paramname"><span class="paramname"><em>ua</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the <a class="el" href="#gae778375f43278246f52713c263113a2a" title="pch_devib_t represents a device on a CU">pch_devib_t</a> of a device from its CU and unit address. </p>
<p>This is a direct array member dereference into the devibs array in the CU. There is no checking that ua is in range. </p>

</div>
</div>
<a id="ga3ddc35aaef2f2adea854c65b93a49eb8" name="ga3ddc35aaef2f2adea854c65b93a49eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ddc35aaef2f2adea854c65b93a49eb8">&#9670;&#160;</a></span>pch_register_devib_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pch_register_devib_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga6924049f57a02761af083fa5498bc092">pch_cbindex_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga70efb52d8b560c38dff57960ae653d9b">pch_devib_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a device callback function at a specific index. </p>
<p>For a Debug build, asserts if n is out of range in the global array of callbacks or if the callback index is already registered. </p>

</div>
</div>
<a id="gade93f39153a74a00a13a0080d994c080" name="gade93f39153a74a00a13a0080d994c080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade93f39153a74a00a13a0080d994c080">&#9670;&#160;</a></span>pch_register_unused_devib_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga6924049f57a02761af083fa5498bc092">pch_cbindex_t</a> pch_register_unused_devib_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga70efb52d8b560c38dff57960ae653d9b">pch_devib_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a device callback function at an unused index. </p>
<p>Panics if no more unused indices are available in the global array of callbacks. This performs a simple linear iteration of the array to find the first unused slot so is not intended to be used at performance sensitive times.</p>
<dl class="section return"><dt>Returns</dt><dd>The allocated callback index number </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
