<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Picochan: Channel programs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Picochan<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Picochan documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('channel_program_page.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Channel programs </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_2channel__program"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md0"></a>
Introduction</h2>
<p>A <em>channel program</em> is a series of (and often just one) 8-byte <em>Channel Command Words</em> (CCWs).</p>
<p>A CCW has API C type <span class="tt"><a class="el" href="group__picochan__base.html#ga0182de6d6c4649114059eb89a140ad6a" title="I/O Channel-Command Word (CCW)">pch_ccw_t</a></span> which is architecturally defined:</p><ul>
<li>8-bit command code</li>
<li>8-bit flags</li>
<li>16-bit data segment size</li>
<li>32-bit data address</li>
</ul>
<p>The required alignment for a CCW is 4-bytes, not 8-bytes, i.e. a CCW must be at an address divisble by 4 but need not be at an address that is divisible by 8.</p>
<p>Each subchannel can be running a channel program independently, started (asynchronously) by the application API <span class="tt">pch_sch_start(sid, ccwaddr)</span> which starts a channel program sending CCW commands to the device addressed by SID <span class="tt">sid</span> (via the channel to its CU) starting with the CCW at address <span class="tt">ccwaddr</span></p>
<p>When the CSS executes a CCW, it sends the device (via communication over the channel to the CU that owns the device) a request with the given command code in the CCW. That can simply be a "Write" (command code 1) or "Read" (command code 2) - where Write and Read mean whatever the device driver chooses them to mean - or a different device-driver-documented command code (up to 239) for more complex commands.</p><ul>
<li>All odd command codes are Write-type (the CCW address and size provides a data segment for the device to receive and use to "write to the device")</li>
<li>All even command codes are Read-type (the CCW address and size provides a data segment to be written to by the device).</li>
</ul>
<p>Since the device driver is running on remotely on the CU (whether an entirely differnt Pico or the other core of the same Pico that the CSS runs on) the data transfers from/to the CCW data segment to/from the device happen via the channel and Pico peripherals (DMA, UART, PIO whatever), as driven by the CSS/CU software. This is the the whole point of this software.</p>
<p>The data area for the device to read/write begins with the <span class="tt">(address, count)</span> segment in that first CCW but can continue...</p><ul>
<li>if the "chain-data" flag (<span class="tt">PCH_CCW_FLAG_CD</span>) is set in the CCW flags field, then when the device exhausts that segment, the CSS fetches the next CCW in memory (next 8 bytes) and the device continues its reading/writing from/to the <span class="tt">(address,count)</span> in the new CCW. For that new ("data-chained") CCW, the command field is ignored.</li>
</ul>
<p>When the data area is exhausted from that CCW command (the segment data-chained CCWs), the channel program will finish...unless the "chain-command" flag is set in the most recent CCW. See further down for what happens for command chaining.</p>
<p>When the channel program finishes, it is because the device has sent a channel operation to the CSS saying "UpdateStatus" (a CU-&gt;CSS operation code) with an 8-bit device status whose flags say "finish the channel program".</p>
<p>The "device status" is an 8-bit architected set of flags for the device to inform the CSS and the application</p><ul>
<li>The device can inform the CSS at any time about its status - it arrives at the CSS from the CU in an "UpdateStatus" protocol operation</li>
<li>When a device has finished processing a CCW command, it will (and indeed must) send an UpdateStatus with a device status whose flags indicate that completion</li>
<li>A device can send an UpdateStatus even when it is not in the process of dealing with a channel program - this is known as an "unsolicited" device status and it includes an "Alert" flag so that an application can be notified asynchronously about an event of interest at a device even when no channel program is in progress for that subchannel.</li>
<li>The CSS makes that 8-bit device status visible to the application by storing it in the devs field in the Subchannel Status Word ("SCSW") part of the SCHIB at times in time for when the subchannel is notified. Some fields of the SCSW, including that for the device status, may not contain meaningful values at other times.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
When a CCW command in a channel program is finished</h2>
<p>When the device has finished with one CCW command (including any following data-chained CCWs) it sends an UpdateStatus with a device status whose flags indicate that it has finished that CCW command (flags including DeviceEnd and ChannelEnd)</p>
<p>At this point the CSS looks at the status of the subchannel and the flags field of the CCW to decide how to continue, testing the following conditions in order:</p><ul>
<li>If the subchannel has any unusual state (for example a CSS-side error or the application has done a <span class="tt">pch_sch_halt(sid)</span>) then then the channel program ends - see the "Channel program ending" section below.</li>
<li>If the CCW "chain-command" flag (<span class="tt">PCH_CCW_FLAG_CC</span>) is <em>not</em> set, then the channel program ends</li>
<li>If the device status has flags that indicate any "unusual conditions" (anything other than a simple DeviceEnd|ChannelEnd and an optional StatusModifier) then the channel program ends</li>
<li>Here, the subchannel is OK, the device status indicates the CCW command was processed with no unusual conditions and the CCW CCW "chain-command" flag is present: the CSS proceeds with "command chaining" as described immediately below.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Channel program command chaining</h2>
<p>When an individual CCW command has finished and command-chaining is appropriate (see above for when that is), rather than ending the channel program, the CSS proceeds by fetching another CCW.</p><ul>
<li>If the device status did <em>not</em> include the StatusModifier flag, then the next CCW fetched is the one in memory immediately after the previous CCW (i.e. at an address 8 bytes beyond the previous CCW address)</li>
<li>If the device status <em>did</em> include the StatusModifier flag, then the CCW "skips" the next CCW and fetches the one after that (i.e. at an address 16 bytes beyond the previous CCW address)</li>
</ul>
<p>The CSS then considers that newly fetched CCW for processing by testing CCW flags as though in the following order:</p><ul>
<li>If the "suspend" (S) flag (<span class="tt">PCH_CCW_FLAG_SUSPEND</span>) is set, then the CSS "suspends" the channel program:<ul>
<li>the application is notified (see below) just as it would be if the channel program ended but the CCW address and other fields in the schib are set so that the channel program can be resumed from its current position</li>
<li>with the channel program suspended, the application can inspect the schib and do whatever it likes, including updating CCWs in memory. It can then resume the channel program by calling <span class="tt">pch_sch_resume(sid)</span> and the CSS resumes the channel program from where it left off.</li>
</ul>
</li>
<li>If the "program controlled interruption" (PCI) flag (<span class="tt">PCH_CCW_FLAG_PROGRAM_CONTROLLED_INTERRUPTION</span>) is set, then the CSS triggers a notification to the application (see below) with the schib indicating the current channel program information (CCW address, status and so on) at this point but immediately continues executing the channel program (as described below) without stopping. The continuing channel program may (and probably will) cause the SCSW to be updated as it progresses so what the application sees, if it looks, will depend on when it looks.</li>
</ul>
<p>Here, the CSS is going to "command-chain" and thus continue the channel program. If the CCW command is a normal one (1-239) then the CSS sends the command for execution just as at the start of the channel program and the program continues in that fashion.</p>
<p>However, as well as those normal CCW commands that can be sent to the device (as described at the beginning of the description of CCWs and channel programs) there is an additional CCW command that can be used when chaining: "Transfer In Channel" (TIC) which has CCW command code decimal 240, hex 0xf0 (<span class="tt">PCH_CCW_CMD_TIC</span>). (This specific command code value is different from that for mainframe I/O.)</p>
<p>The CCW command TIC is the equivalent of a "goto" or "jump" for the channel program and causes the CSS to get the memory address field of the CCW (usually used as a data segment pointer) and treat it as the memory address of the next CCW to be fetched. The CSS then fetches that new CCW and continues the channel program from there, subject to a few corner cases.</p>
<p>It is valid (and common) to have a channel program with a loop and it is valid to TIC to a TIC CCW but there are some corner case conditions which are not yet checked and are probably not handled correctly/sensibly by Picochan at the moment.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Channel program ending</h2>
<p>When the channel program finishes, the CSS "notifies" the application unless the application has chosen to avoid that by setting various mask bits.</p>
<p>Similarly to how IRQs typically allow masking and enabling/disabling in various ways, the CSS provides ways for the application to choose how/when an event happening for a SCHIB (such as a channel program ending) triggers notification.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Notification to application</h2>
<p>An event happens on a subchannel</p><ul>
<li>when a channel program ends</li>
<li>when a device explicitly sends its device status to the CSS and includes the "Alert" flag</li>
<li>when the CSS fetches a CCW while progressing a channel program and the CCW includes the "Suspend" (S) flag or the "Program Controlled Interruption" (PCI) flag.</li>
</ul>
<p>The application can either detect and manage these events using API calls (see further down) or can arrange that the CSS notifies the application when they happen by means of an asynchronous notification.</p>
<p>Such an asynchronous notification is via an "I/O Interuption" which, on Pico, is implemented by the raising of the "CSS I/O IRQ". The IRQ number for that is (must be) set at or after software CSS initialisation time with the API call <span class="tt">pch_css_set_io_irq(io_irqnum)</span>. The IRQ chosen should be one not used by any real peripheral - RP2040 and RP2350 have quite a few non-externally-connected IRQs that are convenient for this purpose.</p>
<p>Each subchannel has an Interrupt Service Class ("ISC") which is a 3-bit number (0-7) which defaults to 0. The ISC for a schib is in the Path Management Control Word ("PMCW") field and can be modified (at any time) with the general API call <span class="tt">pch_sch_modify(sid, pmcw)</span> or its convenient more specific variant <span class="tt">pch_sch_modify_isc(sid, iscnum)</span>.</p>
<p>A global 8-bit "I/O interruption mask" (one for each ISC) determines whether a SCHIB with an I/O notification pending actually raises the I/O IRQ. The mask can be set using API call <span class="tt">pch_css_set_isc_enable_mask(mask)</span> and, as usual with such an IRQ enablement mask, when a bit changes from 0 to 1 any pending SCHIBs with the ISC will cause the notification to happen at that point.</p>
<p>Although an application could write and set an IRQ handler itself to manage I/O interrupts, it may well instead want to set the IRQ handler to the provided handler function <span class="tt">pch_css_io_irq_handler</span> and set a callback function with <span class="tt"><a class="el" href="group__picochan__css.html#ga982b69c5ef0b515d74bdf514b228a896" title="Sets a callback function which pch_css_io_irq_handler will invoke on subchannels with unmasked ISC an...">pch_css_set_io_callback(io_callback_t io_callback)</a></span>. In this case, schib notifications cause that provided handler to retrieve the state information, clear down the notification (see the "TEST SUBCHANNEL" function, <span class="tt"><a class="el" href="group__picochan__css.html#ga13a70bb0036e2d1d807cf89c4ad72e59" title="Test the status of a subchannel, clearing various status conditions of status is pending.">pch_sch_test()</a></span>) and call the callback function with the interruption code (<span class="tt"><a class="el" href="intcode_8h.html#a842ba171eeebce9d1277c4d801753759">pch_intcode_t</a></span>) and SCSW (<span class="tt"><a class="el" href="scsw_8h.html#ad6e95e2ce5ec537f79eda577b03cae8b">pch_scsw_t</a></span>) as direct arguments.</p>
<p>Instead of getting an asynchronous notification by an I/O interrupt or callback, an application can choose to retrieve and reset the "notification pending" state of a subchannel itself - this should be while the ISC for the subchannel is masked (i.e. the bit in the ISC enablement mask for the subchannel's ISC should be zero) or else there is a race condition when the CSS handles the notification itself.</p>
<p>There are three main API calls related to inspecting and resetting interruption conditions and related state for subchannels. This state all resides in the SCSW part of the schib.</p><ul>
<li><span class="tt">pch_sch_store(sid, schib)</span> fetches the current value of the schib and writes it to the <span class="tt"><a class="el" href="group__picochan__base.html#ga3b35c1d1ecbdbb04f997457dc8b28506" title="pch_schib_t is the Subchannel Information Block (SCHIB)">pch_schib_t</a> *schib</span> pointer. The convenience function <span class="tt">pch_sch_store_scsw(sid, scsw)</span> just fetches the SCSW field of the schib and writes that to its pointer argument. Either way, this is a "look but not touch" API call which copies the SCSW (atomically) at the precise moment the function is called and no subchannel state is changed.</li>
<li><span class="tt">pch_sch_test(sid, scsw)</span> corresponds to the mainframe I/O instruction "TEST SUBCHANNEL" and this is the usual way to do deal with non-asynchronous notification of a subchannel but the naming is counter-intuitive. As well as fetching the current SCSW from the subchannel, it atomically tests to see whether the subchannel is in an "interruption condition" state and, if so, it <em>resets</em> that state:<ul>
<li>After calling <span class="tt">pch_sch_test</span> on a subchannel that is causing an interruption condition, the subchannel<ul>
<li>is removed from the pending list and will no longer cause an I/O interruption, even if the ISC bit corresponding to the subchannel's ISC is re-enabled in the global ISC mask.</li>
<li>has the relevant parts of the SCSW cleared/reset so that it is no longer "status pending" - in particular, the <span class="tt">PCH_SC_STATUS_PENDING</span> flag is cleared from <span class="tt">ctrl_flags</span></li>
</ul>
</li>
<li><em>Without</em> calling <span class="tt">pch_sch_test</span> on a subchannel, a subchannel that is causing an interruption condition will remain in that state and, simply returning from the I/O interrupt handler will mean the handler is immediately re-entered. If the I/O interrupt handler is set to <span class="tt">pch_css_io_irq_handler</span> then that function calls <span class="tt">pch_sch_test</span> for you in order to retrieve the SCSW and call your callback function (set with <span class="tt">pch_css_set_io_callback</span>) with the retrieved SCSW. The other argument to your callback function is the <span class="tt"><a class="el" href="intcode_8h.html#a842ba171eeebce9d1277c4d801753759">pch_intcode_t</a></span> that has the corresponding SID.</li>
</ul>
</li>
<li><span class="tt"><a class="el" href="group__picochan__css.html#ga99bbed087f8d0aea5f6d6f240316c3fa" title="Test if there is a pending I/O interruption.">pch_test_pending_interruption()</a></span> (no arguments) tests whether any subchannel at all is currently causing an interrupt condition (whether masked or not). It should usually only be called when the ISC mask bits are disabled for the ISC of any subchannel that may possibly cause an interruption or else there is a race condition between the <span class="tt"><a class="el" href="group__picochan__css.html#ga99bbed087f8d0aea5f6d6f240316c3fa" title="Test if there is a pending I/O interruption.">pch_test_pending_interruption()</a></span> and the I/O interrupt handler being invoked. The type of the return value is <span class="tt"><a class="el" href="intcode_8h.html#a842ba171eeebce9d1277c4d801753759">pch_intcode_t</a></span> which has two fields: a SID and a condition code (0-3).<ul>
<li>If a subchannel is causing an interruption condition, the <span class="tt"><a class="el" href="intcode_8h.html#a842ba171eeebce9d1277c4d801753759">pch_intcode_t</a></span> returned has its SID and cc=0. In this case, the interruption condition state is removed from the subchannel and it will no longer cause an interruption. However, the "status pending" and associated flags in the SCSW remain until inspected/cleared with <span class="tt">pch_sch_test</span>.</li>
<li>If no subchannel is causing an interruption condition, the <span class="tt"><a class="el" href="intcode_8h.html#a842ba171eeebce9d1277c4d801753759">pch_intcode_t</a></span> returned has cc=1 (and the SID is zero but meaningless)</li>
<li>The order that subchannels are tested by <span class="tt">pch_test_pending_interruption</span> is in order of increasing ISC so subchannels with low ISC numbers have "higher priority" in terms of triggering interruption conditions than higher ISCs. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
