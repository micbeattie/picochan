<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Picochan: Control Unit (CU) API for Device Drivers Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Picochan<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Picochan documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('cu_api_page.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Control Unit (CU) API for Device Drivers Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_2cu__api"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Introduction</h2>
<ul>
<li>"Device driver" software runs on core of CU and talks to actual devices</li>
<li>"Device driver" is not a recognised term from the architectural view, and especially not from the application and channel subsystem side, but seems to be as good a term as any to use to refer to the software written to run CU-side to deal with the actual devices</li>
<li>All device driver API calls are non-blocking (dozens to at most hundreds of cycles) and have no timing constraints</li>
<li>API calls set some bits, update linked lists and cause the CU to send a single 4-byte operation packet down the channel to the CSS or, if already busy, queue it up so that CU will send it as soon as the current queue of operation commands have been sent</li>
<li>At software init, register at least one callback function - there can be up to 239 per CU</li>
<li>At device init time, <span class="tt"><a class="el" href="group__picochan__cu.html#gac3e9e409735deb678f3aa637929e2308" title="Set callback for device.">pch_dev_set_callback()</a></span> to set callback for "Start"</li>
<li>When CSS fetches a CCW for the device with its <span class="tt">(command, flags, address, size)</span> fields, CSS sends Start request to CU which calls device's callback function<ul>
<li>For a Read-type CCW, device uses <span class="tt">pch_dev_send...(...,srcaddr,size)</span> to send one or more chunks of data that (via CU-&gt;CSS) get written to the CCW data segments (CSS data-chains to following CCWs if needed)</li>
<li>For a Write-type CCW, device uses <span class="tt">pch_dev_receive...(...,dstaddr,size)</span> to request chunks of data from the CCW data segments (CSS data-chains to following CCWs if needed)</li>
</ul>
</li>
<li>Arguments to those API calls (or an explicit <span class="tt">pch_dev_set_callback</span>) can set the callback index to a different (already-registered) one to be used the next time the CU has reason to call the device driver</li>
<li>Callbacks can happen<ul>
<li>when a command has been sent (so CU is ready for another)</li>
<li>when a requested update is received from CSS about "how much room is
    left in the data segment"</li>
<li>or for (rare) "stop as soon as you can" requests (application "HALT SUBCHANNEL", <span class="tt"><a class="el" href="group__picochan__css.html#gad3a0ad6cfdac814e9a1287f6f22156b2" title="Halt a channel program.">pch_sch_halt()</a></span>)</li>
</ul>
</li>
<li>When device has finished with that CCW command and its (data-chain of) 1 or more CCW segments, it uses <span class="tt">pch_update_status...(...,devstatus)</span> to cause the CSS to finish that CCW command. The devstatus can be<ul>
<li>"normal" (CSS either command-chains to next CCW or notifies final state to application)</li>
<li>include "error" flags (prevents command-chaining and gets notified to application)</li>
<li>or "normal with StatusModifier" (CSS skips a CCW to allow for conditional logic in the channel program decided by device side)</li>
</ul>
</li>
<li>Device driver should document (for the application API user to see) what CCW command codes it recognises and what the associated data of the CCW (if any) is used for<ul>
<li>may well be simply be "CCW command code 1 is Write" (when "Write" has an obvious device-specific meaning) and/or "CCW command code 2
    is Read" (when "Read" has an obivous device-specific meaning).</li>
<li>More complex device drivers may go wild with many different recognised command codes and data segment formats.</li>
<li>Command codes available to device drivers are 1 to 239 (0xef) with even ones being Read-type (application reads from device) and odd ones being Write-type (application writes to device).</li>
</ul>
</li>
</ul>
<p>Since there are not yet enough code comment Doxygen annotations to divide the generated documentation into topics properly, there follows a summary of the main definitions (e.g. types, macros and API functions) for use by CU-side code. They are described in the Doxygen-generated documentation but some may be in a Topics sub-section, some may be in "Data Structures" and some may be under "Files".</p>
<p>Although the above covers the low-levels details of what the CU does and how device drivers must behave, there is now a (somewhat) higher level API for implementing device drivers: this is the "hldev" ("high-level device") API documented in topic picochan_hldev. That should typically be the first API to consider when implementing a device driver.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
Types</h2>
<div class="fragment"><div class="line">typedef struct pch_cu pch_cu_t;</div>
<div class="line"> </div>
<div class="line">typedef uint8_t pch_cbindex_t;</div>
<div class="line"> </div>
<div class="line">typedef struct pch_devib pch_devib_t;</div>
<div class="line"> </div>
<div class="line">typedef void (*pch_devib_callback_t)(pch_cu_t *cu, pch_devib_t *devib);</div>
<div class="line"> </div>
<div class="line">typedef struct pch_dev_sense pch_dev_sense_t;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Compile-time constants and definitions - examples:</h2>
<div class="fragment"><div class="line">#define PCH_NUM_CUS 2</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Debugging assertions:</h2>
<div class="fragment"><div class="line">#define PARAM_ASSERTIONS_ENABLED_PCH_CUS 1</div>
<div class="line">#define PARAM_ASSERTIONS_ENABLED_PCH_DMACHAN 1</div>
<div class="line">#define PARAM_ASSERTIONS_ENABLED_PCH_TXSM 1</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Initialisation of whole CU subsystem</h2>
<div class="fragment"><div class="line">void pch_cus_init(void);</div>
<div class="line"> </div>
<div class="line">bool pch_cus_set_trace(bool trace);</div>
<div class="line"> </div>
<div class="line">pch_cbindex_t pch_register_unused_devib_callback(pch_devib_callback_func_t cbfunc, void *cbctx);</div>
<div class="line"> </div>
<div class="line">// Optionally configure explicit DMA IRQ index(es) (or leave to auto-configure)</div>
<div class="line">void pch_cus_configure_dma_irq_index_exclusive(pch_dma_irq_index_t dmairqix);</div>
<div class="line">void pch_cus_configure_dma_irq_index_shared(pch_dma_irq_index_t dmairqix, uint8_t order_priority);</div>
<div class="line">void pch_cus_configure_dma_irq_index_shared_default(pch_dma_irq_index_t dmairqix);</div>
<div class="line">void pch_cus_ignore_dma_irq_index_t(pch_dma_irq_index_t dmairqix);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Initialisation of each CU</h2>
<div class="fragment"><div class="line">pch_cu_t foo_cu = PCH_CU_INIT(num_devibs);</div>
<div class="line">// or, if num_devbs is not a compile-time constant, initialise at runtime with:</div>
<div class="line">void pch_cu_init(pch_cu_t *cu, uint16_t num_devibs);</div>
<div class="line"> </div>
<div class="line">// register at a given control unit address:</div>
<div class="line">pch_cu_register(pch_cu_t *cu, pch_cuaddr_t cua);</div>
<div class="line"> </div>
<div class="line">bool pch_cus_trace_cu(pch_cuaddr_t cua, bool trace);</div>
<div class="line"> </div>
<div class="line">// Configure connection as a UART channel...:</div>
<div class="line">void pch_cus_auto_configure_uartcu(pch_cuaddr_t cua, uart_inst_t *uart, uint baudrate);</div>
<div class="line">// ...or a memory channel (needs extra configuration):</div>
<div class="line">void pch_cus_memcu_configure(pch_cuaddr_t cua, pch_dmaid_t txdmaid, pch_dmaid_t rxdmaid, dmachan_tx_channel_t *txpeer);</div>
<div class="line"> </div>
<div class="line">// Start CU. Returns immediately after setting all CU handling to</div>
<div class="line">// happen via interrupt handlers and callbacks from those so follow</div>
<div class="line">// with an infinite &quot;__wfe()&quot; loop if there is nothing else to be</div>
<div class="line">// done from main().</div>
<div class="line">void pch_cu_start(pch_cuaddr_t cua);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Convenience API for device driver to its CU</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Convenience API with fully general arguments</h3>
<div class="fragment"><div class="line">int pch_dev_set_callback(pch_devib_t *devib, int cbindex_opt);</div>
<div class="line">int pch_dev_call_or_reject_then(pch_devib_t *devib, pch_dev_call_func_t f, int reject_cbindex_opt);</div>
<div class="line">void pch_dev_call_final_then(pch_devib_t *devib, pch_dev_call_func_t f, int cbindex_opt);</div>
<div class="line"> </div>
<div class="line">int pch_dev_send_then(pch_devib_t *devib, void *srcaddr, uint16_t n, proto_chop_flags_t flags, int cbindex_opt);</div>
<div class="line">int pch_dev_send_zeroes_then(pch_devib_t *devib, uint16_t n, proto_chop_flags_t flags, int cbindex_opt);</div>
<div class="line">int pch_dev_receive_then(pch_devib_t *devib, void *dstaddr, uint16_t size, int cbindex_opt);</div>
<div class="line">int pch_dev_update_status_advert_then(pch_devib_t *devib, uint8_t devs, void *dstaddr, uint16_t size, int cbindex_opt);</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
Convenience API with some fixed arguments</h3>
<ul>
<li>Omitting <span class="tt">_then</span> avoids setting devib callback by hardcoding -1 as the <span class="tt">cbindex_opt</span> argument of the full <span class="tt">_then</span> function.</li>
<li>For <span class="tt">send</span> and <span class="tt">send_zeroes</span> family, the <span class="tt">flags</span> argument is set to<ul>
<li><span class="tt">PROTO_CHOP_FLAG_END</span> for the <span class="tt">_final</span> variant,</li>
<li><span class="tt">PROTO_CHOP_FLAG_RESPONSE_REQUIRED</span> for the _respond variant</li>
<li>0 for the <span class="tt">_norespond</span> variant</li>
</ul>
</li>
<li>For <span class="tt">pch_dev_update_status_ok</span> family, call the corresponding <span class="tt">pch_dev_update_status_</span> function with <span class="tt">DeviceEnd|ChannelEnd</span></li>
<li>For <span class="tt">pch_dev_update_status_error</span> family, set <span class="tt">devib-&gt;sense</span> to the <span class="tt">sense</span> argument then call the corresponding <span class="tt">pch_dev_update_status_</span> function with a device status of <span class="tt">DeviceEnd|ChannelEnd|UnitCheck</span></li>
</ul>
<div class="fragment"><div class="line">int pch_dev_send(pch_devib_t *devib, void *srcaddr, uint16_t n, proto_chop_flags_t flags);</div>
<div class="line">int pch_dev_send_final(pch_devib_t *devib, void *srcaddr, uint16_t n);</div>
<div class="line">int pch_dev_send_final_then(pch_devib_t *devib, void *srcaddr, uint16_t n, int cbindex_opt);</div>
<div class="line">int pch_dev_send_respond(pch_devib_t *devib, void *srcaddr, uint16_t n);</div>
<div class="line">int pch_dev_send_respond_then(pch_devib_t *devib, void *srcaddr, uint16_t n, int cbindex_opt);</div>
<div class="line">int pch_dev_send_norespond(pch_devib_t *devib, void *srcaddr, uint16_t n);</div>
<div class="line">int pch_dev_send_norespond_then(pch_devib_t *devib, void *srcaddr, uint16_t n, int cbindex_opt);</div>
<div class="line">int pch_dev_send_zeroes(pch_devib_t *devib, uint16_t n, proto_chop_flags_t flags);</div>
<div class="line">int pch_dev_send_zeroes_respond_then(pch_devib_t *devib, uint16_t n, int cbindex_opt);</div>
<div class="line">int pch_dev_send_zeroes_respond(pch_devib_t *devib, uint16_t n);</div>
<div class="line">int pch_dev_send_zeroes_norespond_then(pch_devib_t *devib, uint16_t n, int cbindex_opt);</div>
<div class="line">int pch_dev_send_zeroes_norespond(pch_devib_t *devib, uint16_t n);</div>
<div class="line">int pch_dev_receive(pch_devib_t *devib, void *dstaddr, uint16_t size);</div>
<div class="line">int pch_dev_update_status_then(pch_devib_t *devib, uint8_t devs, int cbindex_opt);</div>
<div class="line">int pch_dev_update_status(pch_devib_t *devib, uint8_t devs);</div>
<div class="line">int pch_dev_update_status_advert(pch_devib_t *devib, uint8_t devs, void *dstaddr, uint16_t size);</div>
<div class="line">int pch_dev_update_status_ok_then(pch_devib_t *devib, int cbindex_opt);</div>
<div class="line">int pch_dev_update_status_ok(pch_devib_t *devib);</div>
<div class="line">int pch_dev_update_status_ok_advert(pch_devib_t *devib, void *dstaddr, uint16_t size);</div>
<div class="line">int pch_dev_update_status_error_advert_then(pch_devib_t *devib, pch_dev_sense_t sense, void *dstaddr, uint16_t size, int cbindex_opt);</div>
<div class="line">int pch_dev_update_status_error_then(pch_devib_t *devib, pch_dev_sense_t sense, int cbindex_opt);</div>
<div class="line">int pch_dev_update_status_error_advert(pch_devib_t *devib, pch_dev_sense_t sense, void *dstaddr, uint16_t size);</div>
<div class="line">int pch_dev_update_status_error(pch_devib_t *devib, pch_dev_sense_t sense);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Low-level API for device driver to its CU</h2>
<p>The Convenience API functions above use this low-level API and are more likely to be suitable instead of using these directly.</p>
<div class="fragment"><div class="line">static inline void pch_devib_prepare_callback(pch_devib_t *devib, pch_cbindex_t cbindex);</div>
<div class="line">static inline void pch_devib_prepare_count(pch_devib_t *devib, uint16_t count);</div>
<div class="line">static inline void pch_devib_prepare_write_data(pch_devib_t *devib, void *srcaddr, uint16_t n, proto_chop_flags_t flags);</div>
<div class="line">static inline void pch_devib_prepare_write_zeroes(pch_devib_t *devib, uint16_t n, proto_chop_flags_t flags);</div>
<div class="line">static inline void pch_devib_prepare_read_data(pch_devib_t *devib, void *dstaddr, uint16_t size);</div>
<div class="line">void pch_devib_prepare_update_status(pch_devib_t *devib, uint8_t devs, void *dstaddr, uint16_t size);</div>
<div class="line">void pch_devib_send_or_queue_command(pch_devib_t *devib);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
